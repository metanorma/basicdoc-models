grammar {

document = 
element document {
  attribute identifier { text }?,
  bibdata, sections, references*
}

## Bibliographic description of a document, used as metadata, expressed in the Relaton model
bibdata =
  element bibdata { BibData }

sections = 
  element sections {
    section+
}

## Section: groups of blocks within text, which can also contain other sections
section =
  element section { 
    Basic-Section,
    ## Sections contained within the current section. The relation is recursive,
    ## so the hierarchical arrangement of sections can be arbitrarily deep
    section*
  }

## Two-letter language code taken from ISO-639, indicating the language in which the content is written
LanguageType = text

## Four-letter script code taken from ISO-15924, indicating the script in which the content is written
ScriptType = text

## Group of blocks within text, which is a leaf node in the hierarchical organisation of text (does not contain any sections of its own)
Basic-Section =
    OptionalId,
    attribute language { LanguageType }?,
    attribute script { ScriptType }?,
    ## Title of the section
    section-title?,
    ## Blocks, containing the textual content of the section
    ## (but excluding subsections, which are only present in Hierarchical Sections)
    BasicBlock*

## Sections containing zero or more bibliographical items (as described in Relaton), along with any prefatory text
references =
  element references {
    OptionalId,
    ## Title of section
    section-title?,
    ## Prefatory text
    BasicBlock*,
    ## Bibliographical items included in the References section
    bibitem*
  }

## Title of a section
section-title =
  element title { TextElement* }

BasicBlock =  paragraph-with-footnote | table | formula | admonition | ol | ul | dl | figure |
  quote | sourcecode | example | review | pre | note | pagebreak | hr | bookmark | amend

BasicBlockNoId =  paragraph-with-footnote-no-id | table-no-id | formula-no-id | admonition-no-id | ol-no-id | ul-no-id | dl-no-id | figure-no-id |
  quote-no-id | sourcecode-no-id | example-no-id | review | pre-no-id | note-no-id | pagebreak | hr | bookmark | amend

amend = 
  element amend { AmendType }

AmendType =
    OptionalId,
    attribute change { "add" | "modify" | "delete" | "replace" },
    attribute path { text }?,
    attribute path_end { text }?,
    attribute title { text }?,
    element location { (locality | localityStack)* }?,
    element description { BasicBlock* }?,
    element newcontent {
        OptionalId,
        BasicBlock* }?,
    classification*,
    contributor*

classification = element classification {
  classification_tag, classification_value
}

classification_tag = element tag { text }
classification_value = element value { text }

## Default block of textual content. 
## Unlike the case for other document models, paragraphs _cannot_
## contain other blocks, such as lists, tables, or figures: they are modelled as a basic building block of text
## Does not contain foonotes. While most paragraphs in a document can contain footnotes (paragraph-with-footnote),
## the distinction is necessary, as footnotes are not appropriate for all instances of paragraph content 
## in a document (e.g. sourcecode annotations)
paragraph =
  element p { ParagraphType }

## The alignment of the paragraph against the margins of the document
Alignments = ( "left" | "right" | "center" | "justified" )

## Mandatory anchor of element, to be used for cross-references within the document
RequiredId = 
    attribute id { xsd:ID }

## Optional anchor of element
OptionalId = 
    attribute id { xsd:ID }?

ParagraphAttrs =
    ## The alignment of the paragraph against the margins of the document
    attribute align { Alignments }?

ParagraphType =
    RequiredId,
    ParagraphAttrs,
    ParagraphBody

## Inline elements constituting the content of the paragraph, excluding footnotes
ParagraphBody =
   ## Inline elements constituting the content of the paragraph
   TextElement*,
   note*

## Inline elements constituting the content of the paragraph, including footnotes
ParagraphFnBody =
   (
     ## Inline elements constituting the content of the paragraph
     TextElement |
     ## Footnotes interspersed with paragraph content
     fn
   )*,
   note*

## Paragraph containing no footnotes: optional ID attributes (for use in Relaton, metadata) 
paragraph-no-id =
  element p {
    OptionalId,
    ParagraphAttrs,
    ParagraphBody
  }

## A paragraph which may contain footnotes.
paragraph-with-footnote =
  element p {
    RequiredId,
    ParagraphAttrs,
    ParagraphFnBody
}

## A paragraph which may contain footnotes optional ID attributes (for use in Relaton, metadata)
paragraph-with-footnote-no-id =
  element p {
    OptionalId,
    ParagraphAttrs,
    ParagraphFnBody
}

note =
  element note {
    RequiredId,
    NoteAttr,
    NoteBody
  }

note-no-id =
  element note {
    OptionalId,
    NoteAttr,
    NoteNoIdBody
  }

NoteAttr = empty

NoteBody =
    paragraph+

NoteNoIdBody =
    paragraph-no-id+

review =
  element review {
  RequiredId,
  attribute reviewer { text },
  attribute type { text }?,
  attribute date { xsd:dateTime }?,
  attribute from { xsd:IDREF }?,
  attribute to { xsd:IDREF }?,
  paragraph+
}

NumberingAttributes =
    ## Do not number this block in rendering
    attribute unnumbered { xsd:boolean }?,
    ## Define a subsequence for numbering of this block; e.g. if this block would be numbered
    ## as 7, but it has a subsequence value of XYZ, this block, and all consecutive blocks
    ## of the same class and with the same subsequence value, will be numbered consecutively
    ## with the same number and in a subsequence: 7a, 7b, 7c etc
    attribute subsequence { text }?

formula =
  element formula {
    RequiredId,
    FormulaAttr,
    FormulaBody
}

formula-no-id =
  element formula {
    OptionalId,
    FormulaAttr,
    FormulaNoIdBody
}

FormulaAttr =
    NumberingAttributes,
    attribute inequality { xsd:boolean }?

FormulaBody =
    stem, dl?, note*

FormulaNoIdBody =
    stem, dl-no-id?, note-no-id*

quote =
  element quote {
    RequiredId,
    QuoteAttr,
    QuoteBody
}

quote-no-id =
  element quote {
    OptionalId,
    QuoteAttr,
    QuoteNoIdBody
}

QuoteAttr =
    attribute alignment { Alignments }?

QuoteBody =
    quote-source?,
    quote-author?,
    paragraph-with-footnote+,
    note*

QuoteNoIdBody =
    quote-source?,
    quote-author?,
    paragraph-with-footnote-no-id+,
    note-no-id*

quote-source =
  element source { erefType }

quote-author =
  element author { text }

sourcecode =
  element sourcecode {
    RequiredId,
    SourceAttr,
    SourceBody
  }

sourcecode-no-id =
  element sourcecode {
    OptionalId,
    SourceAttr,
    SourceNoIdBody
  }

SourceAttr =
    NumberingAttributes,
    attribute lang { LanguageType }?

SourceBody =
    tname?, ( text | callout )+, annotation*, note*

SourceNoIdBody =
    tname?, ( text | callout )+, annotation*, note-no-id*

pre =
  element pre {
    RequiredId,
    PreAttr,
    PreBody
  }

pre-no-id =
  element pre {
    OptionalId,
    PreAttr,
    PreNoIdBody
  }

PreAttr =
    attribute alt { text }?

PreBody =
    tname?, text, note*

PreNoIdBody =
    tname?, text, note-no-id*

## Tabular arrangement of text
table =
  element table {
    RequiredId,
    TableAttr,
    TableBody
  }

## Tabular arrangement of text: optional ID attributes recursively (for use in Relaton, metadata)
table-no-id =
  element table {
    OptionalId,
    TableAttr,
    TableNoIdBody
  }

TableAttr =
    NumberingAttributes,
    ## Accessible description of the tabular text, in case the table cannot be rendered accessibly (HTML 5)
    attribute alt { text }?,
    ## Alternative more extensive summary of table to be provided for accessibility purposes, 
    ## in case the table cannot be rendered accessibly (HTML 5)
    attribute summary { text }?,
    ## Online location of content of table (in case the table is available as a separate external document) (HTML 5)
    attribute uri { xsd:anyURI }?

## Elements of table
TableBody =
    ## Caption for the table
    tname?,
    ## Table rows constituting the table header
    thead?,
    ## Table rows constituting the table body
    tbody,
    ## Table rows constituting the table footer
    tfoot?,
    ## Definitions list defining any symbols used in the table
    dl?,
    ## Notes specific to this block
    table-note*

## Elements of table: optional ID attributes recursively (for use in Relaton, metadata)
TableNoIdBody =
    ## Caption for the table
    tname?,
    ## Table rows constituting the table header
    thead-no-id?,
    ## Table rows constituting the table body
    tbody-no-id,
    ## Table rows constituting the table footer
    tfoot-no-id?,
    ## Definitions list defining any symbols used in the table
    dl-no-id?,
    ## Notes specific to this block
    table-note-no-id*

tname = element name { NestedTextElement+ }
thead = element thead { tr }
thead-no-id = element thead { tr-no-id }
tfoot = element tfoot { tr }
tfoot-no-id = element tfoot { tr-no-id }
tbody = element tbody { tr+ }
tbody-no-id = element tbody { tr-no-id+ }

table-note = element note { paragraph }
table-note-no-id = element note { paragraph-no-id }

## Sequence of cells to be displayed as a row in a table
tr =
  element tr { ( 
    ## Data cells in a table row
    td | 
    ## Header cells in a table row
    th 
  )+
}

tr-no-id =
  element tr { ( td-no-id | th-no-id )+ }

## Textual content constituting a basic building block of a table
td =
  element td {
    TdAttr,
    TdBody
}

## Textual content constituting a basic building block of a table: optional ID attributes recursively (for use in Relaton, metadata)
td-no-id =
  element td {
    TdAttr,
    TdNoIdBody
}

TdAttr =
    ## Number of columns in the underlying table grid which the cell spans
    attribute colspan { text }?,
    ## Number of rows in the underlying table grid which the cell spans
    attribute rowspan { text }?,
    ## Horizontal textual alignment of the cell against the underlying table grid
    attribute align { "left" | "right" | "center" }?,
    ## Vertical alignment of the cell against the underlying table grid
    attribute valign { "top" | "middle" | "bottom" | "baseline" }?

TdBody =
    (
      ## Table cell is a block
      (TextElement )* |
      ## Table cell contains a block
      paragraph-with-footnote+
    )

TdNoIdBody =
    (
      (TextElement )* |
      paragraph-with-footnote-no-id+
    )

th =
  element th {
    ThAttr,
    ThBody
}

th-no-id =
  element th {
    ThAttr,
    ThNoIdBody
}

ThAttr = TdAttr

ThBody = TdBody

ThNoIdBody = TdNoIdBody

example =
  element example {
    RequiredId,
    ExampleAttr,
    ExampleBody
}

example-no-id =
  element example {
    OptionalId,
    ExampleAttr,
    ExampleNoIdBody
}

ExampleAttr =
    NumberingAttributes

ExampleBody =
    tname?,
    ( formula | ul | ol | dl | quote | sourcecode | paragraph-with-footnote )+,
    note*

ExampleNoIdBody =
    tname?,
    ( formula-no-id | ul-no-id | ol-no-id | dl-no-id | quote-no-id | sourcecode-no-id | paragraph-with-footnote-no-id )+,
    note-no-id*

## A sidebar block outside of the main flow of text, conveying particular warnings or supplementary text to the reader
admonition =
  element admonition {
    RequiredId,
    AdmonitionAttr,
    AdmonitionBody
}

admonition-no-id =
  element admonition {
    OptionalId,
    AdmonitionAttr,
    AdmonitionNoIdBody
}

AdmonitionAttr =
    ## Subclass of admonition determining how it is to be rendered. 
    ## Distinct admonition types are often associated with distinct icons or rendering
    attribute type { AdmonitionType },
    ## Subclass of admonition, allowing different runs of admonitions to be labelled
    ## and auto-numbered differently, even if they are of the same type.
    ## Typically is a subclass of an admonition type
    attribute class { text }?,
    ## Location where the content of the admonition is accessible as an external document
    attribute uri { xsd:anyURI }?

AdmonitionBody =
    ## Caption of admonition
    tname?,
    paragraph-with-footnote*,
    note*

AdmonitionNoIdBody =
    tname?,
    paragraph-with-footnote-no-id*,
    note-no-id*

## Subclass of admonition determining how it is to be rendered
AdmonitionType =
  ## Warning to reader, note of risk to be avoided
  "warning" |
  ## Supplementary, explanatory information
  "note" |
  ## Instructive information to assist in the fulfilment of tasks related to content
  "tip" |
  ## Note to reader of something crucial to be borne in mind
  "important" |
  ## Caution to reader, note of potential surprise or difficulty
  "caution" 

figure =
  element figure {
    RequiredId,
    FigureAttr,
    FigureBody
  }

figure-no-id =
  element figure {
    OptionalId,
    FigureAttr,
    FigureNoIdBody
  }

FigureAttr =
    NumberingAttributes,
    attribute class { text }?

FigureBody =
     source?, tname?, 
     (image | video | audio | pre | paragraph-with-footnote+ | figure*), 
     fn*, dl?, note*

FigureNoIdBody =
     source?, tname?, 
     (image-no-id | video-no-id | audio-no-id | pre-no-id | paragraph-with-footnote-no-id+ | figure-no-id*), 
     fn*, dl-no-id?, note-no-id*

## Any inline element containing text and associated formatting information.
## Includes inline elements that are identifiers or references to identifiers
TextElement =
  text | em | eref | strong | stem | sub | sup | tt | underline | keyword | ruby |
  strike | smallcap | xref | br | hyperlink | hr | pagebreak | bookmark | image | index | index-xref

## Inline element containing text and associated formatting information,
## but which does not contain any associated identifiers or references to identifiers.
## Restricted recursively to contain only other such inline elements with no identifiers or references to identifiers
PureTextElement =
  text | pure_em | pure_strong | sub | sup | pure_tt | pure_underline | pure_strike | pure_smallcap | br

## Contents of TextElement tags: leaves out tags that should occur only at top level of block: bookmark image hr pagebreak
NestedTextElement = PureTextElement|stem|eref|xref|hyperlink|index|index-xref|ruby|keyword

source = element source { TypedUri }

## Emphasised text. Corresponds to HTML `em`, `i`
em = element em { NestedTextElement* }
## Emphasised text for PureTextElement
pure_em = element em { PureTextElement* }
## Strong text. Corresponds to HTML `strong`, `b`
strong = element strong { NestedTextElement* }
## Strong text for PureTextElement
pure_strong = element strong { PureTextElement* }
## Monospace text. Corresponds to HTML `tt`, `code`
tt = element tt { NestedTextElement* }
## Monospace text for PureTextElement
pure_tt = element tt { PureTextElement* }
## Keyword text
keyword = element keyword { (PureTextElement|index|index-xref)* }
## Subscript text. Corresponds to HTML `sub`
sub = element sub { PureTextElement* }
## Superscript text. Corresponds to HTML `sup`
sup = element sup { PureTextElement* }
## Strikethrough text. Corresponds to HTML 4 `s`
strike = element strike { NestedTextElement* }
## Strikethrough for PureTextElement
pure_strike = element strike { PureTextElement* }
## Underlined text. Corresponds to HTML 4 `u`
underline = element underline { 
  ## CSS style to apply to underline (intended for text-decoration-style attribute keyword values: solid double dotted dashed wavy)
  attribute style { text }?,
  NestedTextElement*
}
## Underlined text for PureTextElement
pure_underline = element underline { 
  attribute style { text }?,
  PureTextElement*
}
## Small caps text
smallcap = element smallcap { NestedTextElement* }
## Small caps text for PureTextElement
pure_smallcap = element smallcap { PureTextElement* }

## Text with Ruby annotations in East Asian languages. Corresponds to HTML `ruby`
ruby = element ruby { 
  (
    ## Ruby annotation giving pronunciation
    ruby_pronunciation | 
    ## Ruby annotation giving other (semantic) information
    ruby_annotation
  ), ( 
     ## Ruby annotated text which contains no further annotations
     text | 
     ## Ruby annotated text which itself contains other Ruby annotations
     ruby 
  ) 
}

## Ruby annotation giving pronunciation of text
ruby_pronunciation = element pronunciation {
  ## Ruby annotation value
  attribute value { text },
  attribute script { ScriptType }?,
  attribute lang { LanguageType }? 
}

## Ruby annotation giving information other than pronunciation of text
ruby_annotation = element annotation {
  ## Ruby annotation value
  attribute value { text },
  attribute script { ScriptType }?,
  attribute lang { LanguageType }?
}

br = element br { empty }
hr = element hr { empty }
pagebreak = element pagebreak { empty }

index = element index {
  attribute to { xsd:IDREF }?,
  element primary { PureTextElement+ },
  element secondary { PureTextElement+ }?,
  element tertiary { PureTextElement+ }?
}

## A reference to an index term, cross-referenced within an index as an
## alternative index entry, either as a "see" or a "see also" cross-reference.
## The text in the inline element is the primary index term to be be cross-referenced
index-xref = element index-xref {
  ## The cross-reference is to be treated as "see also" rather than as "see"
  attribute also { xsd:boolean },
  ## The primary index term to be cross-referenced
  element primary { PureTextElement+ },
  ## The secondary index term to be cross-referenced
  element secondary { PureTextElement+ }?,
  ## The tertiary index term to be cross-referenced
  element tertiary { PureTextElement+ }?,
  ## The index term to be cross-referenced to
  element target { PureTextElement+ }
}


# bare ID element, used for referencing arbitrary spans of text
bookmark =
  element bookmark {
  RequiredId,
  empty
}

## The type of Reference Element, prescribing how it is to be rendered
ReferenceFormat =
  ## Reference to an external document
  "external" |
  ## Reference to another element in the same document
  "inline" |
  ## Inline reference to a block to be rendered as a footnote
  "footnote" |
  ## Inline reference to a block to be referenced as a sourcecode callout
  "callout"

## An external reference to a bibliographic entity
eref =
  element eref { erefType }

erefType =
    ## Whether the reference is to be treated as normative or informative, particularly in the context of normative documents such as standards
    attribute normative { xsd:boolean }?,
    ## Form that the bibliographic citation should take when it is rendered
    attribute citeas { text },
    ## The type of Reference Element, prescribing how it is to be rendered
    attribute type { ReferenceFormat },
    ## Alternate text, used for accessibility
    attribute alt { text }?,
    ## Reference cross-reference: modelled as cross-reference to the corresponding bibliographical item in a References section
    CitationType,
    ## The textual content of the element. The `text` is what we wish to show the link as (e.g., the "content" of `<xx>my link text</xx>`)
    PureTextElement+

## A reference to an external document or resource
hyperlink =
  element link {
    ## The location or online identifier of the external document or resource
    attribute target { xsd:anyURI },
    ## The type of Reference Element, prescribing how it is to be rendered
    attribute type { ReferenceFormat },
    ## Alternate text, used for accessibility
    attribute alt { text }?,
    ## The textual content of the element. The `text` is what we wish to show the link as (e.g., the "content" of `<xx>my link text</xx>`)
    PureTextElement+
}

## Inline element, which references an identifier of a document, a block in a document, or an element in a document
xref =
  element xref {
     ## The identifier of a section, block or inlined element being referenced
     attribute target { xsd:IDREF },
     ## The type of Reference Element, prescribing how it is to be rendered
     attribute type { ReferenceFormat },
     ## Alternate text, used for accessibility
     attribute alt { text }?,
     ## The textual content of the element. The `text` is what we wish to show the link as (e.g., the "content" of `<xx>my link text</xx>`)
     PureTextElement+
}

## Inline reference to a paragraph or paragraphs, appearing as a footnote.
## The target of a footnote is the location it is embedded in within the text
fn =
  element fn {
    ## The number of the footnote, used to identify it visually
    attribute reference { text },
    ## The content of the footnote
    paragraph+
}

## Inline reference to a paragraph or paragraphs, appearing as annotation of source code
callout =
  element callout {
    ## The target of the callout is understood to be the location of the callout within the source code; 
    ## the extent of the target is not expressed overtly
    attribute target { xsd:IDREF },
    ## The label of the callout, used to identify its target within the source code
    text
  }

# This is xref with fixed @type="callout"; the target by convention is in an annotation in the same source code snippet
# so <callout target="xyz">1</callout>
# corresponds to <xref type="callout" target="xyz">1</xref>
image = element image { 
    RequiredId,
    ImageAttr
}

image-no-id = element image { 
    OptionalId,
    ImageAttr
}

ImageAttr =
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?,
    attribute width { ImageSize }?,
    attribute height { ImageSize }?,
    attribute alt { text }?,
    attribute title { text }?,
    attribute longdesc { xsd:anyURI }?

ImageSize = xsd:string { pattern = "\d+([.]\d+)?(%?)" } | "auto"

video =
  element video {
    RequiredId,
    VideoAttr,
    VideoBody
}

video-no-id = 
  element video {
    OptionalId,
    VideoAttr,
    VideoBody
}

VideoAttr =
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?,
    attribute width { xsd:int | "auto" }?,
    attribute height { xsd:int | "auto" }?,
    attribute alt { text }?,
    attribute title { text }?,
    attribute longdesc { xsd:anyURI }?

VideoBody =
    altsource*

audio =
  element audio {
    RequiredId,
    AudioAttr,
    AudioBody
}

audio-no-id =
  element audio {
    OptionalId,
    AudioAttr,
    AudioBody
}

AudioAttr =
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?,
    attribute alt { text }?,
    attribute title { text }?,
    attribute longdesc { xsd:anyURI }?

AudioBody =
    altsource*

altsource =
  element altsource {
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?
}


## Mathematically formatted text
stem =
  element stem {
    ## The notation used to mathematically format the text
    attribute type { "MathML" | "AsciiMath" | "LaTeX" },
    ## The content of the mathematically formatted text
    ( text | AnyElement )+
}

annotation =
  element annotation {
    RequiredId,
    paragraph
}

ul =
  element ul {
    RequiredId,
    UlAttr,
    UlBody
}

ul-no-id =
  element ul {
    OptionalId,
    UlAttr,
    UlNoIdBody
}

UlAttr = empty

UlBody =
    li+, note*

UlNoIdBody =
    li-no-id+, note-no-id*

li =
  element li {
    OptionalId,
    LiAttr,
    LiBody
}

li-no-id =
  element li {
    OptionalId,
    LiAttr,
    LiNoIdBody
}

LiAttr = empty

LiBody =
    paragraph-with-footnote+

LiNoIdBody =
    paragraph-with-footnote-no-id+

ol =
  element ol {
    RequiredId,
    OlAttr,
    OlBody
}

ol-no-id =
  element ol {
    OptionalId,
    OlAttr,
    OlNoIdBody
}

OlAttr =
    attribute type { ( "roman" | "alphabet" | "arabic" |
                       "roman_upper" | "alphabet_upper" ) },
    attribute start { text }?

OlBody =
    li+, note*

OlNoIdBody =
    li-no-id+, note-no-id*

dl =
  element dl {
    RequiredId,
    DlAttr,
    DlBody
}

dl-no-id =
  element dl {
    OptionalId,
    DlNoIdBody
}

DlAttr = empty

DlBody =
    (dt, dd)+, note*

DlNoIdBody =
    (dt, dd-no-id)+, note-no-id*

dt =
  element dt { TextElement* }

dd =
  element dd { paragraph-with-footnote* }

dd-no-id =
  element dd { paragraph-with-footnote-no-id* }

}
