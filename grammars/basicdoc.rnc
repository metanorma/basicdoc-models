grammar {

document = 
element document {
  attribute identifier { text }?,
  bibdata, sections, references*
}

## Bibliographic description of a document, used as metadata, expressed in the Relaton model
bibdata =
  element bibdata { BibData }

sections = 
  element sections {
    section+
}

section =
  element section { 
    Basic-Section,
    section*
  }

## Two-letter language code taken from ISO-639, indicating the language in which the content is written
LanguageType = text

## Four-letter script code taken from ISO-15924, indicating the script in which the content is written
ScriptType = text

Basic-Section =
    attribute id { xsd:ID }?,
    attribute language { LanguageType }?,
    attribute script { ScriptType }?,
    section-title?,
    BasicBlock*

references =
  element references {
    attribute id { xsd:ID }?,
    section-title?,
    BasicBlock*,
    bibitem*
  }

section-title =
  element title { TextElement* }

BasicBlock =  paragraph-with-footnote | table | formula | admonition | ol | ul | dl | figure |
  quote | sourcecode | example | review | pre | note | pagebreak | hr | bookmark | amend

BasicBlockNoId =  paragraph-with-footnote-no-id | table-no-id | formula-no-id | admonition-no-id | ol-no-id | ul-no-id | dl-no-id | figure-no-id |
  quote-no-id | sourcecode-no-id | example-no-id | review | pre-no-id | note-no-id | pagebreak | hr | bookmark | amend

amend = 
  element amend { AmendType }

AmendType =
    attribute id { xsd:ID }?,
    attribute change { "add" | "modify" | "delete" | "replace" },
    attribute path { text }?,
    attribute path_end { text }?,
    attribute title { text }?,
    element location { (locality | localityStack)* }?,
    element description { BasicBlock* }?,
    element newcontent {
        attribute id { xsd:ID }?,
        BasicBlock* }?,
    classification*,
    contributor*

classification = element classification {
  classification_tag, classification_value
}

classification_tag = element tag { text }
classification_value = element value { text }

paragraph =
  element p { ParagraphType }

Alignments = ( "left" | "right" | "center" | "justified" )

## Mandatory anchor of element
RequiredId = 
    attribute id { xsd:ID }

## Optional anchor of element
OptionalId = 
    attribute id { xsd:ID }?

ParagraphAttrs =
    attribute align { Alignments }?

ParagraphType =
    RequiredId,
    ParagraphAttrs,
    ParagraphBody

ParagraphBody =
   ( TextElement )*, note*

ParagraphFnBody =
   ( TextElement | fn )*, note*

paragraph-no-id =
  element p {
    OptionalId,
    ParagraphAttrs,
    ParagraphBody
  }

paragraph-with-footnote =
  element p {
    RequiredId,
    ParagraphAttrs,
    ParagraphFnBody
}

paragraph-with-footnote-no-id =
  element p {
    OptionalId,
    ParagraphAttrs,
    ParagraphFnBody
}

note =
  element note {
    RequiredId,
    NoteAttr,
    NoteBody
  }

note-no-id =
  element note {
    OptionalId,
    NoteAttr,
    NoteNoIdBody
  }

NoteAttr = empty

NoteBody =
    paragraph+

NoteNoIdBody =
    paragraph-no-id+

review =
  element review {
  RequiredId,
  attribute reviewer { text },
  attribute type { text }?,
  attribute date { xsd:dateTime }?,
  attribute from { xsd:IDREF }?,
  attribute to { xsd:IDREF }?,
  paragraph+
}

NumberingAttributes =
    ## Do not number this block in rendering
    attribute unnumbered { xsd:boolean }?,
    ## Define a subsequence for numbering of this block; e.g. if this block would be numbered
    ## as 7, but it has a subsequence value of XYZ, this block, and all consecutive blocks
    ## of the same class and with the same subsequence value, will be numbered consecutively
    ## with the same number and in a subsequence: 7a, 7b, 7c etc
    attribute subsequence { text }?

formula =
  element formula {
    RequiredId,
    FormulaAttr,
    FormulaBody
}

formula-no-id =
  element formula {
    OptionalId,
    FormulaAttr,
    FormulaNoIdBody
}

FormulaAttr =
    NumberingAttributes,
    attribute inequality { xsd:boolean }?

FormulaBody =
    stem, dl?, note*

FormulaNoIdBody =
    stem, dl-no-id?, note-no-id*

quote =
  element quote {
    RequiredId,
    QuoteAttr,
    QuoteBody
}

quote-no-id =
  element quote {
    OptionalId,
    QuoteAttr,
    QuoteNoIdBody
}

QuoteAttr =
    attribute alignment { Alignments }?

QuoteBody =
    quote-source?,
    quote-author?,
    paragraph-with-footnote+,
    note*

QuoteNoIdBody =
    quote-source?,
    quote-author?,
    paragraph-with-footnote-no-id+,
    note-no-id*

quote-source =
  element source { erefType }

quote-author =
  element author { text }

sourcecode =
  element sourcecode {
    RequiredId,
    SourceAttr,
    SourceBody
  }

sourcecode-no-id =
  element sourcecode {
    OptionalId,
    SourceAttr,
    SourceNoIdBody
  }

SourceAttr =
    NumberingAttributes,
    attribute lang { LanguageType }?

SourceBody =
    tname?, ( text | callout )+, annotation*, note*

SourceNoIdBody =
    tname?, ( text | callout )+, annotation*, note-no-id*

pre =
  element pre {
    RequiredId,
    PreAttr,
    PreBody
  }

pre-no-id =
  element pre {
    OptionalId,
    PreAttr,
    PreNoIdBody
  }

PreAttr =
    attribute alt { text }?

PreBody =
    tname?, text, note*

PreNoIdBody =
    tname?, text, note-no-id*

## Tabular arrangement of text
table =
  element table {
    RequiredId,
    TableAttr,
    TableBody
  }

## Tabular arrangement of text: optional ID attributes recursively (for use in Relaton, metadata)
table-no-id =
  element table {
    OptionalId,
    TableAttr,
    TableNoIdBody
  }

TableAttr =
    NumberingAttributes,
    ## Accessible description of the tabular text, in case the table cannot be rendered accessibly (HTML 5)
    attribute alt { text }?,
    ## Alternative more extensive summary of table to be provided for accessibility purposes, 
    ## in case the table cannot be rendered accessibly (HTML 5)
    attribute summary { text }?,
    ## Online location of content of table (in case the table is available as a separate external document) (HTML 5)
    attribute uri { xsd:anyURI }?

## Elements of table
TableBody =
    ## Caption for the table
    tname?,
    ## Table rows constituting the table header
    thead?,
    ## Table rows constituting the table body
    tbody,
    ## Table rows constituting the table footer
    tfoot?,
    ## Definitions list defining any symbols used in the table
    dl?,
    ## Notes specific to this block
    table-note*

## Elements of table: optional ID attributes recursively (for use in Relaton, metadata)
TableNoIdBody =
    ## Caption for the table
    tname?,
    ## Table rows constituting the table header
    thead-no-id?,
    ## Table rows constituting the table body
    tbody-no-id,
    ## Table rows constituting the table footer
    tfoot-no-id?,
    ## Definitions list defining any symbols used in the table
    dl-no-id?,
    ## Notes specific to this block
    table-note-no-id*

tname = element name { NestedTextElement+ }
thead = element thead { tr }
thead-no-id = element thead { tr-no-id }
tfoot = element tfoot { tr }
tfoot-no-id = element tfoot { tr-no-id }
tbody = element tbody { tr+ }
tbody-no-id = element tbody { tr-no-id+ }

table-note = element note { paragraph }
table-note-no-id = element note { paragraph-no-id }

## Sequence of cells to be displayed as a row in a table
tr =
  element tr { ( 
    ## Data cells in a table row
    td | 
    ## Header cells in a table row
    th 
  )+
}

tr-no-id =
  element tr { ( td-no-id | th-no-id )+ }

## Textual content constituting a basic building block of a table
td =
  element td {
    TdAttr,
    TdBody
}

## Textual content constituting a basic building block of a table: optional ID attributes recursively (for use in Relaton, metadata)
td-no-id =
  element td {
    TdAttr,
    TdNoIdBody
}

TdAttr =
    ## Number of columns in the underlying table grid which the cell spans
    attribute colspan { text }?,
    ## Number of rows in the underlying table grid which the cell spans
    attribute rowspan { text }?,
    ## Horizontal textual alignment of the cell against the underlying table grid
    attribute align { "left" | "right" | "center" }?,
    ## Vertical alignment of the cell against the underlying table grid
    attribute valign { "top" | "middle" | "bottom" | "baseline" }?

TdBody =
    (
      ## Table cell is a block
      (TextElement )* |
      ## Table cell contains a block
      paragraph-with-footnote+
    )

TdNoIdBody =
    (
      (TextElement )* |
      paragraph-with-footnote-no-id+
    )

th =
  element th {
    ThAttr,
    ThBody
}

th-no-id =
  element th {
    ThAttr,
    ThNoIdBody
}

ThAttr = TdAttr

ThBody = TdBody

ThNoIdBody = TdNoIdBody

example =
  element example {
    RequiredId,
    ExampleAttr,
    ExampleBody
}

example-no-id =
  element example {
    OptionalId,
    ExampleAttr,
    ExampleNoIdBody
}

ExampleAttr =
    NumberingAttributes

ExampleBody =
    tname?,
    ( formula | ul | ol | dl | quote | sourcecode | paragraph-with-footnote )+,
    note*

ExampleNoIdBody =
    tname?,
    ( formula-no-id | ul-no-id | ol-no-id | dl-no-id | quote-no-id | sourcecode-no-id | paragraph-with-footnote-no-id )+,
    note-no-id*

admonition =
  element admonition {
    RequiredId,
    AdmonitionAttr,
    AdmonitionBody
}

admonition-no-id =
  element admonition {
    OptionalId,
    AdmonitionAttr,
    AdmonitionNoIdBody
}

AdmonitionAttr =
    attribute type { AdmonitionType },
    attribute class { text }?,
    attribute uri { xsd:anyURI }?

AdmonitionBody =
    tname?,
    paragraph-with-footnote*,
    note*

AdmonitionNoIdBody =
    tname?,
    paragraph-with-footnote-no-id*,
    note-no-id*

AdmonitionType =
  "warning" | "note" | "tip" | "important" | "caution" 

figure =
  element figure {
    RequiredId,
    FigureAttr,
    FigureBody
  }

figure-no-id =
  element figure {
    OptionalId,
    FigureAttr,
    FigureNoIdBody
  }

FigureAttr =
    NumberingAttributes,
    attribute class { text }?

FigureBody =
     source?, tname?, 
     (image | video | audio | pre | paragraph-with-footnote+ | figure*), 
     fn*, dl?, note*

FigureNoIdBody =
     source?, tname?, 
     (image-no-id | video-no-id | audio-no-id | pre-no-id | paragraph-with-footnote-no-id+ | figure-no-id*), 
     fn*, dl-no-id?, note-no-id*

## Any inline element containing text and associated formatting information.
## Includes inline elements that are identifiers or references to identifiers
TextElement =
  text | em | eref | strong | stem | sub | sup | tt | underline | keyword | ruby |
  strike | smallcap | xref | br | hyperlink | hr | pagebreak | bookmark | image | index | index-xref

## Inline element containing text and associated formatting information,
## but which does not contain any associated identifiers or references to identifiers.
## Restricted recursively to contain only other such inline elements with no identifiers or references to identifiers
PureTextElement =
  text | pure_em | pure_strong | sub | sup | pure_tt | pure_underline | pure_strike | pure_smallcap | br

## Contents of TextElement tags: leaves out tags that should occur only at top level of block: bookmark image hr pagebreak
NestedTextElement = PureTextElement|stem|eref|xref|hyperlink|index|index-xref|ruby|keyword

source = element source { TypedUri }

## Emphasised text. Corresponds to HTML `em`, `i`
em = element em { NestedTextElement* }
## Emphasised text for PureTextElement
pure_em = element em { PureTextElement* }
## Strong text. Corresponds to HTML `strong`, `b`
strong = element strong { NestedTextElement* }
## Strong text for PureTextElement
pure_strong = element strong { PureTextElement* }
## Monospace text. Corresponds to HTML `tt`, `code`
tt = element tt { NestedTextElement* }
## Monospace text for PureTextElement
pure_tt = element tt { PureTextElement* }
## Keyword text
keyword = element keyword { (PureTextElement|index|index-xref)* }
## Subscript text. Corresponds to HTML `sub`
sub = element sub { PureTextElement* }
## Superscript text. Corresponds to HTML `sup`
sup = element sup { PureTextElement* }
## Strikethrough text. Corresponds to HTML 4 `s`
strike = element strike { NestedTextElement* }
## Strikethrough for PureTextElement
pure_strike = element strike { PureTextElement* }
## Underlined text. Corresponds to HTML 4 `u`
underline = element underline { 
  ## CSS style to apply to underline (intended for text-decoration-style attribute keyword values: solid double dotted dashed wavy)
  attribute style { text }?,
  NestedTextElement*
}
pure_underline = element underline { 
  attribute style { text }?,
  PureTextElement*
}
## Small caps text
smallcap = element smallcap { NestedTextElement* }
pure_smallcap = element smallcap { PureTextElement* }

## Text with Ruby annotations in East Asian languages. Corresponds to HTML `ruby`
ruby = element ruby { 
  (
    ## Ruby annotation giving pronunciation
    ruby_pronunciation | 
    ## Ruby annotation giving other (semantic) information
    ruby_annotation
  ), ( 
     ## Ruby annotated text which contains no further annotations
     text | 
     ## Ruby annotated text which itself contains other Ruby annotations
     ruby 
  ) 
}

## Ruby annotation giving pronunciation of text
ruby_pronunciation = element pronunciation {
  ## Ruby annotation value
  attribute value { text },
  attribute script { ScriptType }?,
  attribute lang { LanguageType }? 
}

## Ruby annotation giving information other than pronunciation of text
ruby_annotation = element annotation {
  ## Ruby annotation value
  attribute value { text },
  attribute script { ScriptType }?,
  attribute lang { LanguageType }?
}

br = element br { empty }
hr = element hr { empty }
pagebreak = element pagebreak { empty }

index = element index {
  attribute to { xsd:IDREF }?,
  element primary { PureTextElement+ },
  element secondary { PureTextElement+ }?,
  element tertiary { PureTextElement+ }?
}

index-xref = element index-xref {
  attribute also { xsd:boolean },
  element primary { PureTextElement+ },
  element secondary { PureTextElement+ }?,
  element tertiary { PureTextElement+ }?,
  element target { PureTextElement+ }
}


# bare ID element, used for referencing arbitrary spans of text
bookmark =
  element bookmark {
  attribute id { xsd:ID },
  empty
}

ReferenceFormat = ( "external" | "inline" | "footnote" | "callout" )

eref =
  element eref { erefType }

erefType =
    attribute normative { xsd:boolean }?,
    attribute citeas { text },
    attribute type { ReferenceFormat },
    attribute alt { text }?,
    CitationType,
    PureTextElement+

hyperlink =
  element link {
    attribute target { xsd:anyURI },
    attribute type { ReferenceFormat },
    attribute alt { text }?,
    PureTextElement+
}
xref =
  element xref {
     attribute target { xsd:IDREF },
     attribute type { ReferenceFormat },
     attribute alt { text }?,
     PureTextElement+
}

fn =
  element fn {
    attribute reference { text },
    paragraph+
}
# This is xref with fixed @type="footnote", and @target built in as paragraph+
# @reference replaces ReferenceElement/text
# so <fn reference="2"><p>This is a footnote</p></fn>
# corresponds to 
# <eref type="footnote" target="fn2">2</xref> <p id="fn2">This is a footnote</p>

callout =
  element callout {
    attribute target { xsd:IDREF },
    text
  }

# This is xref with fixed @type="callout"; the target by convention is in an annotation in the same source code snippet
# so <callout target="xyz">1</callout>
# corresponds to <xref type="callout" target="xyz">1</xref>
image = element image { 
    RequiredId,
    ImageAttr
}

image-no-id = element image { 
    OptionalId,
    ImageAttr
}

ImageAttr =
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?,
    attribute width { ImageSize }?,
    attribute height { ImageSize }?,
    attribute alt { text }?,
    attribute title { text }?,
    attribute longdesc { xsd:anyURI }?

ImageSize = xsd:string { pattern = "\d+([.]\d+)?(%?)" } | "auto"

video =
  element video {
    RequiredId,
    VideoAttr,
    VideoBody
}

video-no-id = 
  element video {
    OptionalId,
    VideoAttr,
    VideoBody
}

VideoAttr =
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?,
    attribute width { xsd:int | "auto" }?,
    attribute height { xsd:int | "auto" }?,
    attribute alt { text }?,
    attribute title { text }?,
    attribute longdesc { xsd:anyURI }?

VideoBody =
    altsource*

audio =
  element audio {
    RequiredId,
    AudioAttr,
    AudioBody
}

audio-no-id =
  element audio {
    OptionalId,
    AudioAttr,
    AudioBody
}

AudioAttr =
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?,
    attribute alt { text }?,
    attribute title { text }?,
    attribute longdesc { xsd:anyURI }?

AudioBody =
    altsource*

altsource =
  element altsource {
    attribute src { xsd:anyURI },
    attribute mimetype { text },
    attribute filename { text }?
}


## Mathematically formatted text
stem =
  element stem {
    ## The notation used to mathematically format the text
    attribute type { "MathML" | "AsciiMath" | "LaTeX" },
    ## The content of the mathematically formatted text
    ( text | AnyElement )+
}

annotation =
  element annotation {
    RequiredId,
    paragraph
}

ul =
  element ul {
    RequiredId,
    UlAttr,
    UlBody
}

ul-no-id =
  element ul {
    OptionalId,
    UlAttr,
    UlNoIdBody
}

UlAttr = empty

UlBody =
    li+, note*

UlNoIdBody =
    li-no-id+, note-no-id*

li =
  element li {
    OptionalId,
    LiAttr,
    LiBody
}

li-no-id =
  element li {
    OptionalId,
    LiAttr,
    LiNoIdBody
}

LiAttr = empty

LiBody =
    paragraph-with-footnote+

LiNoIdBody =
    paragraph-with-footnote-no-id+

ol =
  element ol {
    RequiredId,
    OlAttr,
    OlBody
}

ol-no-id =
  element ol {
    OptionalId,
    OlAttr,
    OlNoIdBody
}

OlAttr =
    attribute type { ( "roman" | "alphabet" | "arabic" |
                       "roman_upper" | "alphabet_upper" ) },
    attribute start { text }?

OlBody =
    li+, note*

OlNoIdBody =
    li-no-id+, note-no-id*

dl =
  element dl {
    RequiredId,
    DlAttr,
    DlBody
}

dl-no-id =
  element dl {
    OptionalId,
    DlNoIdBody
}

DlAttr = empty

DlBody =
    (dt, dd)+, note*

DlNoIdBody =
    (dt, dd-no-id)+, note-no-id*

dt =
  element dt { TextElement* }

dd =
  element dd { paragraph-with-footnote* }

dd-no-id =
  element dd { paragraph-with-footnote-no-id* }

}
